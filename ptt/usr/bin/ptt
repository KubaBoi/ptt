#!/usr/bin/env python3
"""
Test tool for ProgTests from CVUT FIT

version: 0.5.27
"""
__docformat__ = "reStructedText"

import sys
import subprocess
import argparse
import os
import time
import inspect
import random
import math
import string

class Runner:
	
	@staticmethod
	def convertTime(tm):
		if (C.MILLI_SECONDS): return f"{1000 * tm} ms"
		return f"{tm} s"

	@staticmethod
	def readFiles(files_path):
		return sorted( filter( lambda x: os.path.isfile(os.path.join(files_path, x)),
		                os.listdir(files_path) ) )

	@staticmethod
	def run(script_path, input_file, output_file, cmd):
		index = cmd.index(f"./{script_path.replace('.c', '')}")
		cmd[index] += f" < \"{input_file}\" > \"{output_file}\""
		tm = time.time()
		ret = subprocess.call(" ".join(cmd), shell=True)
		return ret, time.time() - tm

	@staticmethod		
	def runTests(script_path, files_path, cmd):
		counter = 0
		fails = 0
		
		if (os.path.isdir(files_path)):
			files = Runner.readFiles(files_path)

			for i, file in enumerate(files):
				if (i % 3 != 0): continue
				
				C.prnt("");
				C.prnt(f"{C.HEADER}{5*'='}Test {counter}. - {file}{5*'='}{C.ENDC}")
				counter += 1
				
				fails += Runner.runOneFile(script_path, os.path.join(files_path, file), cmd)
		else:
			C.prnt("");
			C.prnt(f"{C.HEADER}{5*'='}Test {counter}. - {files_path}{5*'='}{C.ENDC}")
			counter += 1
			
			fails = Runner.runOneFile(script_path, files_path, cmd)
			
		C.prnt(20*"=")
		C.prnt(f"Test count: {counter}")
		C.prnt(f"Failed tests: {fails}")
		
	@staticmethod
	def runOneFile(script_path, file, cmd):
		ret, tm = Runner.run(script_path, file, "tmp.txt", cmd.copy())
		if (ret != 0):
			C.prnt(f"{C.WARNING}{10*'='}Process ended with code {C.OKBLUE}{ret}{C.WARNING}{10*'='}{C.ENDC}")			
		
		with open("tmp.txt", "r", encoding="utf-8") as f:
			out = f.read()
		os.remove("tmp.txt")
		
		with open(file.replace("in", "out"), "r", encoding="utf-8") as fo:
			temp = fo.read()
		
		if (temp != out):	
			with open(file, "r", encoding="utf-8") as f:
				in_data = f.read()
			
			C.prnt("")
			C.prnt("Input:")
			
			C.prnt(in_data)
			
			out_split = out.split("\n")
			temp_split = temp.split("\n")
			
			C.prnt("")
			C.prnt("Output:")
			
			for line1, line2 in zip(out_split, temp_split):
				h = f"{C.OKGREEN}>> {C.ENDC}"
				if (line1 != line2): h = f"{C.FAIL}>> {C.ENDC}"
				C.prnt(f"{h}{line1}{(30 - len(line1)) * ' '} {C.BOLD}|{C.ENDC} {line2}")
				
			if (len(out_split) > len(temp_split)):
				for i in range(len(temp_split), len(out_split)):
					line = out_split[i]
					C.prnt(f"{C.FAIL}>> {C.ENDC}" + line)
					
			elif (len(temp_split) > len(out_split)):
				for i in range(len(out_split), len(temp_split)):
					line = temp_split[i]
					C.prnt(f"{C.FAIL}>> {C.ENDC}" + ((30 - len(line)) * " ") + f" {C.BOLD}|{C.ENDC} " + line)
			
			C.prnt("")
			C.prnt(5*"=")
			C.prnt(f"{C.FAIL}Output not matching{C.ENDC}")
			C.prnt(f"Time: {Runner.convertTime(tm)}")
			return 1
		else:
			C.prnt(f"{C.OKGREEN}OK{C.ENDC}")
			C.prnt(f"Time: {Runner.convertTime(tm)}")
			return 0


class M:
	MAKE_FILE_TEMP = """
# MAKEFILE GENERATED BY PTT
# https://github.com/KubaBoi/ptt

NAME=$NAME$
OBJFILES=$(NAME).o $MODULES$

CC=$COMPILER$
CFLAGS= $COMPILER_ARGS$

%.o : %.c 
	$(CC) $(CFLAGS) -c $<

all: $(NAME)

dep:
	$(CC) -MM *.c >dep.list

-include dep.list

$(NAME): $(OBJFILES)
	$(CC) $(CFLAGS) $(OBJFILES) -o $@
	"""


class V:
	VERSION = "0.5.27"


class C:
	HEADER = '\033[95m'
	OKBLUE = '\033[94m'
	OKCYAN = '\033[96m'
	OKGREEN = '\033[92m'
	WARNING = '\033[93m'
	FAIL = '\033[91m'
	ENDC = '\033[0m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'
	
	SILENT = False
	MILLI_SECONDS = False
	
	@staticmethod
	def noColors():
		members = inspect.getmembers(C, lambda a:not(inspect.isroutine(a)))
		for i in members:
			if (i[0][0] != "_"): setattr(C, i[0], "")
			
	@staticmethod
	def silent():
		C.SILENT = True
		
	@staticmethod
	def milliseconds():
		C.MILLI_SECONDS = True
			
	@staticmethod
	def prnt(*str):
		if (not C.SILENT): print(*str)

class InvalidRegex(Exception):
    def __init__(self, description):
        super().__init__(self, "Invalid regex", description)


class Specifier:

    @staticmethod
    def findLimits(val, min, max):
        limits = val.split(",")
        if (len(limits) != 0):
            if (len(limits) == 1):
                min = 0
                max = float(limits[0])
            else:
                min = float(limits[0])
                max = float(limits[1])
        return min, max

    @staticmethod
    def char(val):
        val = val.replace("%", "").replace("c", "")
        return random.choice(string.ascii_letters)

    @staticmethod
    def decimal(val):
        val = val.replace("%", "").replace("d", "")
        min, max = Specifier.findLimits(val, -32768, 32768)

        return str(random.randrange(int(min), int(max)))

    @staticmethod
    def string(val):
        val = val.replace("%", "").replace("s", "")
        min, max = Specifier.findLimits(val, -1, 100)

        if (min != -1):
            length = random.randrange(int(min), int(max))
        else:
            length = max

        return "".join(random.choices(string.ascii_letters + string.digits,
                k=length))

    @staticmethod
    def double(val):
        val = val.replace("%", "").replace("g", "")
        min, max = Specifier.findLimits(val,
            2.3*math.pow(10, -308),
            1.7*math.pow(10, 308))
        
        return str(random.uniform(min, max))

    @staticmethod
    def flt(val):
        val = val.replace("%", "").replace("f", "")
        min, max = Specifier.findLimits(val,
            1.2*math.pow(10, -38),
            3.4*math.pow(10, 38))
        
        return str(random.uniform(min, max))



class Compilator:

	@staticmethod
	def findModules(script_path):
		headers = [] 
		sources = []
		for root, dirs, files in os.walk(os.path.dirname(os.path.abspath(script_path))):
			for f in files:
				if (f.endswith(".h")):
					headers.append(f.replace(".h", ".o"))
				elif (f.endswith(".c")):
					sources.append(f.replace(".c", ".o"))
					
		modules = []
		for source in sources: 
			if (source in headers):	
				modules.append(source)
				C.prnt("Adding module:", source) 
		return modules

	@staticmethod
	def removeLinks(script_path):
		for root, dirs, files in os.walk(os.path.dirname(os.path.abspath(script_path))):
			for f in files:
				if (f.endswith(".o")): os.remove(f)
	
	@staticmethod
	def compile(script_path, compiler, compiler_args):
		name = os.path.basename(script_path).replace(".c", "")
		modules = Compilator.findModules(script_path)
			
		mkf = M.MAKE_FILE_TEMP
		mkf = mkf.replace("$NAME$", name)
		mkf = mkf.replace("$MODULES$", " ".join(modules))
		mkf = mkf.replace("$COMPILER$", compiler)
		mkf = mkf.replace("$COMPILER_ARGS$", " ".join(compiler_args))
		
		with open("Makefile", "w") as f:
			f.write(mkf)
		
		ret = subprocess.call(["make"])
		if (ret != 0):
			C.prnt(f"{C.FAIL}{10*'='}Compilation process ended with code {C.OKCYAN}{ret}{C.FAIL}{10*'='}{C.ENDC}")
		else:
			C.prnt(f"{C.OKGREEN}{10*'='}Compilation process OK{10*'='}{C.ENDC}")
		return ret


class Generator:
    """
    Class for dataset generation

    Regex:
        as scanf in c/c++

    Range:
        Every value can have a range

        If range not included then it is totaly random value

        Example:
            %0,5d - decimal number from 0 to 5 (5 not included)
            %10,500s - string with length from 10 to 500 characters (500 included because ending zero)
    
        Groups:
            $(%5,12d - %10s - %f\n)5,10$ 
            
                - 5 to 10 lines with 
                one decimal from 5 to 12, string length 10 and random float

            $(%0,250d,%1,8f,%-10.54,150g\n)5,9$:%2,15s

                - 5 to 9 lines with decimal, float, double 
                and at the end is one 2 to 15 characters long string
    """

    SPECS = {
        "c": "char",
        "d": "decimal",
        "s": "string",
        "g": "double",
        "f": "flt",
        "o": "octa",
        "u": "unsigned",
        "x": "hexa",
        "X": "hexa"
    }

    def __init__(self):
        self.reg = input("Regex for your test data: ")
        self.reg = self.reg.replace("\\n", "\n")
        self.reg = self.reg.replace("\\t", "\t")

    def findSpecs(self, reg):
        specsValues = []

        ignore = -1
        for i, char in enumerate(reg):
            if (i <= ignore): 
                if (ignore == i): ignore = -1
                continue

            if (char == "\\"):
                ignore = i + 1
            elif (char == "%"):
                val = char
                start_index = i
                i += 1
                char = reg[i]
                while (char.isnumeric() or char == "-" or char == "." or char == ","):
                    val += char
                    i += 1
                    if (i >= len(reg)): 
                        raise InvalidRegex(f"Missing end of regex specification at {start_index} position")
                    char = reg[i]

                if (char not in self.SPECS.keys()):
                    raise InvalidRegex(f"Uknown regex specification at {start_index} position")
                val += char
                specsValues.append(val)
            elif (char == "$"):
                val = char
                start_index = i
                i += 1
                char = reg[i]
                if (char != "("):
                    continue

                while (char != "$"):
                    val += char
                    i += 1
                    if (i >= len(reg)):
                        raise InvalidRegex(f"Missing end of group regex specification at {start_index} position")
                    char = reg[i]
                
                ignore = i
                val += char
                rng = val.replace("$", "").split(")")[-1]
                valS = val.replace("$(", "").replace(f"){rng}$", "")
                specsValues.append([rng, self.findSpecs(valS), val])
        return specsValues

    def getName(self, number, count):
        s_number = str(number)
        s_count = str(count)

        val = ""
        for i in range(len(s_count) - len(s_number)):
            val += "0"
        val += s_number + "_in.txt"
        return val

    def generateOne(self, reg, specs):
        for val in specs:
            if (isinstance(val, list)):
                min, max = Specifier.findLimits(val[0], 0, 1000)
                cnt = random.randrange(int(min), int(max))
                vr = ""
                for i in range(cnt):
                    vr += self.generateOne(val[2], val[1])
                vr = vr.replace("$(", "").replace(f"){val[0]}$", "")
                val = val[2]
            else:
                fcn = getattr(Specifier, self.SPECS[val[-1]])
                vr = fcn(val) 
            index = reg.find(val)
            reg = reg[:index] + vr + reg[index + len(val):]
        return reg

    def generate(self, count=100):
        self.specsValues = self.findSpecs(self.reg)
        pth = "./SamplesPPT"

        if (os.path.exists(pth)):
            if (os.path.isdir(pth)):
                i = input(f"{pth} directory already exists. Do you want to continue? [y/n]: ")
                if (i != "y"): return 1
            else:
                print(f"{pth} already exists and it is not a directory.")
                return 1
        else:
            os.mkdir(pth)

        print(f"Generating {count} files...")
        self.printProgressBar(0, count, "Generating:", "Done:", length=50)
        for i in range(count):
            data = self.generateOne(self.reg, self.specsValues)
            with open(os.path.join(pth, self.getName(i, count)), "w") as f:
                f.write(data)
            self.printProgressBar(i+1, count, "Generating:", "Done:", length=50)

    def printProgressBar(self, iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = 'â–ˆ', printEnd = "\r"):
        percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
        filledLength = int(length * iteration // total)
        bar = fill * filledLength + '-' * (length - filledLength)
        print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)
        # Print New Line on Complete
        if iteration == total: 
            print()




def main():
	"""
	Entry point into the program.
	"""
	
	parser = argparse.ArgumentParser(
		prog="ptt",
		description="Test tool for ProgTest from CVUT FIT",
		epilog="Full documentation 'man ptt'")
		
	parser.add_argument("filename", 
			help="Path to C/C++ script")
			
	parser.add_argument("-i", "--install", action="store_true", default=False,
			help="Install/update. Need super user.")
	parser.add_argument("-u", "--uninstall", action="store_true", default=False,
			help="Uninstall. Need super user.")
	parser.add_argument("-v", "--version", action="store_true", default=False,
			help="Show version")
			
	parser.add_argument("-d", "--data-path", action="store", default=False,
		        help="Path to directory with test data. If path is file, then script is runned only once with data from path file. If not included, then script is runned only once and waits for users input.")
	parser.add_argument("-l", "--valgrind", action="store_true",
			help="Script is runned under Valgrind")
	parser.add_argument("-L", "--val-args", action="store", default="",
			help="Arguments for Valgrind as string and needs to start with \\")
	parser.add_argument("-D", "--val-data", action="store", default="",
			help="Data for Valgrind as string")
	parser.add_argument("-c", "--compiler", action="store", default="g++",
			help="Compiler (default is g++)")
	parser.add_argument("-C", "--compiler-args", action="store", default="\\-Wall -pedantic",
			help="Arguments for compiler (default is '-Wall -pedantic')")
	parser.add_argument("-k", "--keep-links", action="store_true", default=False,
			help="Keeps link (.o) files from compilation")

	parser.add_argument("-g", "--generate", action="store_true", default=False,
			help="Starts generator for new dataset and then tests the script")
			
	parser.add_argument("-m", "--milli-seconds", action="store_true", default=False,
			help="Time is counted in milliseconds")
	parser.add_argument("-s", "--silent", action="store_true", default=False,
			help="ptt will be silent (compiler, valgrind and tested script won't be)")
	parser.add_argument("-n", "--no-colors", action="store_true", default=False,
			help="Output is without any colors")
	
	args = parser.parse_args()
	script_path = args.filename
	
	if (args.no_colors):
		C.noColors()
	if (args.silent):
		C.silent()
	if (args.milli_seconds):
		C.milliseconds()
	
	if (args.valgrind):
		val_args = args.val_args.replace("\\", "").strip()
		cmd = ["valgrind", f"{val_args}", f"./{script_path.replace('.c', '')}", f"{args.val_data}"]
	else:
		cmd = [f"./{script_path.replace('.c', '')}"]
	
	while ("" in cmd):
		cmd.remove("")
	
	compiler = args.compiler
	compiler_args = args.compiler_args.replace("\\", "").split(" ")
	
	if (Compilator.compile(script_path, compiler, compiler_args) == 0):
		if (not args.keep_links):
			Compilator.removeLinks(script_path)
	
		if (not args.data_path):
			subprocess.call(cmd)
		else:
			Runner.runTests(script_path, args.data_path, cmd)
		
		C.prnt("\n")
		C.prnt("Testing done:")
		C.prnt("Compiler:", compiler)
		C.prnt("Compiler args:", *compiler_args)
		C.prnt("Valgrind:", args.valgrind)
		C.prnt("Valgrind args:", args.val_args)
		C.prnt("")
		if ("-Wall" not in compiler_args or "-pedantic" not in compiler_args):
			C.prnt(f"{C.WARNING}WARNING - there is missing -Wall or -pedantic in compilation{C.ENDC}")
		if (not args.valgrind):
			if (args.val_args != ""):
				C.prnt(f"{C.WARNING}WARNING - there are valgrind arguments (-V) specified but valgrind (-v) is not enabled{C.ENDC}")
			if (args.val_data != ""):
				C.prnt(f"{C.WARNING}WARNING - there are valgrind data (-D) specified but valgrind (-v) is not enabled{C.ENDC}")

if (__name__ == "__main__"):
	args = args = sys.argv
	if (len(args) > 1):
		if (args[1] == "-v" or args[1] == "--version"):
			exit(f"ProgTestTest v({V.VERSION})")
		elif (args[1] == "-g" or args[1] == "--generate"):
			g = Generator()
			count = int(input("How many files do you want to generate? "))
			g.generate(count)
			exit()
	exit(main())

