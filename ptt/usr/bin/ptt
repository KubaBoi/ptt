#!/usr/bin/env python3
"""
Test tool for ProgTests from CVUT FIT

version: 1.0.16
"""
__docformat__ = "reStructedText"

import os
import random
import subprocess
import math
import string
import sys
import argparse
import time
import inspect

class Generator:
    """
    Class for dataset generation

    Regex:
        as scanf in c/c++

    Range:
        Every value can have a range

        If range not included then it is totaly random value

        Example:
            %0,5d - decimal number from 0 to 5 (5 not included)
            %10,500s - string with length from 10 to 500 characters (500 included because ending zero)
    
        Groups:
            $(%5,12d - %10s - %f\n)5,10$ 
            
                - 5 to 10 lines with 
                one decimal from 5 to 12, string length 10 and random float

            $(%0,250d,%1,8f,%-10.54,150g\n)5,9$:%2,15s

                - 5 to 9 lines with decimal, float, double 
                and at the end is one 2 to 15 characters long string
    """

    SPECS = {
        "c": "char",
        "d": "decimal",
        "s": "string",
        "g": "double",
        "f": "flt",
        "o": "octa",
        "u": "unsigned",
        "x": "hexa",
        "X": "hexA"
    }

    def __init__(self):
        #self.reg = "$(%0,250d,%100,8000x,%100,8000X,%o,%-10.54,150g\n)5,9$:%2,15s"
        self.reg = input("Regex for your test data: ")
        self.reg = self.reg.replace("\\n", "\n")
        self.reg = self.reg.replace("\\t", "\t")

    def findSpecs(self, reg):
        specsValues = []

        ignore = -1
        for i, char in enumerate(reg):
            if (i <= ignore): 
                if (ignore == i): ignore = -1
                continue

            if (char == "\\"):
                ignore = i + 1
            elif (char == "%"):
                val = char
                start_index = i
                i += 1
                char = reg[i]
                while (char.isnumeric() or char == "-" or char == "." or char == ","):
                    val += char
                    i += 1
                    if (i >= len(reg)): 
                        raise InvalidRegex(f"Missing end of regex specification at {start_index} position")
                    char = reg[i]

                if (char not in self.SPECS.keys()):
                    raise InvalidRegex(f"Uknown regex specification at {start_index} position")
                val += char
                specsValues.append(val)
            elif (char == "$"):
                val = char
                start_index = i
                i += 1
                char = reg[i]
                if (char != "("):
                    continue

                while (char != "$"):
                    val += char
                    i += 1
                    if (i >= len(reg)):
                        raise InvalidRegex(f"Missing end of group regex specification at {start_index} position")
                    char = reg[i]
                
                ignore = i
                val += char
                rng = val.replace("$", "").split(")")[-1]
                valS = val.replace("$(", "").replace(f"){rng}$", "")
                specsValues.append([rng, self.findSpecs(valS), val])
        return specsValues

    def getName(self, number, count):
        s_number = str(number)
        s_count = str(count)

        val = ""
        for i in range(len(s_count) - len(s_number)):
            val += "0"
        val += s_number + "_in.txt"
        return val

    def generateOne(self, reg, specs):
        for val in specs:
            if (isinstance(val, list)):
                min, max = Specifier.findLimits(val[0], 0, 1000)
                cnt = random.randrange(int(min), int(max))
                vr = ""
                for i in range(cnt):
                    vr += self.generateOne(val[2], val[1])
                vr = vr.replace("$(", "").replace(f"){val[0]}$", "")
                val = val[2]
            else:
                fcn = getattr(Specifier, self.SPECS[val[-1]])
                vr = fcn(val) 
            index = reg.find(val)
            reg = reg[:index] + vr + reg[index + len(val):]
        return reg

    def generate(self, count=100):
        self.specsValues = self.findSpecs(self.reg)
        pth = "./SamplesPPT"

        if (os.path.exists(pth)):
            if (os.path.isdir(pth)):
                i = input(f"{pth} directory already exists. Do you want to continue? [y/n]: ")
                if (i != "y"): return 1
            else:
                print(f"{pth} already exists and it is not a directory.")
                return 1
        else:
            os.mkdir(pth)

        print(f"Generating {count} files...")
        self.printProgressBar(0, count, "Generating:", "Done:", length=50)
        for i in range(count):
            data = self.generateOne(self.reg, self.specsValues)
            with open(os.path.join(pth, self.getName(i, count)), "w") as f:
                f.write(data)
            self.printProgressBar(i+1, count, "Generating:", "Done:", length=50)

    def printProgressBar(self, iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = 'â–ˆ', printEnd = "\r"):
        percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
        filledLength = int(length * iteration // total)
        bar = fill * filledLength + '-' * (length - filledLength)
        print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)
        # Print New Line on Complete
        if iteration == total: 
            print()

class Builder:

    @staticmethod
    def build(file, output):
        dir_name = os.path.dirname(file)
        output = os.path.join(dir_name, output)
        if (output == file): 
            print("")
            return 0

        with open(file, "r", encoding="utf-8") as f:
            data_lines = f.readlines()

        includes = []
        done_includes = []
        header = f"""/*
* This one file source has been generated by ProgTestTest
*
* https://github.com/KubaBoi/ptt
*
* version: {V.VERSION}
*/

"""
        new_data = f"{header}$INCLUDES$\n"
        for line in data_lines:
            if (line.lower().startswith("#include")):
                parts = line.split("\"")
                if (len(parts) != 3): 
                    includes.append(line)
                    continue

                if (line in done_includes): continue

                header_name = parts[1]
                cont = Builder.openHeader(dir_name, header_name, done_includes)
                if (cont == 0): 
                    includes.append(line)
                    continue
                done_includes.append(line)
                new_data += cont[0] + "\n"

                for incl in cont[1]:
                    if (incl not in includes): includes.append(incl)
            else:
                new_data += line

        includesString = ""
        for incl in includes:
            includesString += incl

        with open(output, "w", encoding="utf-8") as f:
            f.write(new_data.replace("$INCLUDES$", includesString))

        return output

    @staticmethod
    def openHeader(dir_name, header_name, done_includes):
        if (not header_name.endswith(".h") or
            not os.path.exists(os.path.join(dir_name, header_name))): 
            return 0

        content = ""

        src_name = header_name[:-1] + "c"
        hasSrc = os.path.exists(os.path.join(dir_name, src_name))

        with open(os.path.join(dir_name, header_name), "r", encoding="utf-8") as f:
            header_lines = f.readlines()
        
        includes = []
        for line in header_lines:
            low_line = line.lower().strip()
            if (low_line.startswith("#include")):
                parts = line.split("\"")
                if (len(parts) != 3): 
                    includes.append(line)
                    continue

                if (line in done_includes): continue

                hdr_name = parts[1]
                cont = Builder.openHeader(dir_name, hdr_name, done_includes)
                if (content == 0): 
                    includes.append(line)
                    continue
                done_includes.append(line)
                content += cont[0] + "\n"

                for incl in cont[1]:
                    if (incl not in includes): includes.append(incl)
            elif ((low_line.startswith("#define") and
                not low_line.endswith("_h")) or
                not hasSrc):
                content += line
                

        content += "\n"
        if (hasSrc):
            with open(os.path.join(dir_name, src_name), "r", encoding="utf-8") as f:
                data_lines = f.readlines()

            for line in data_lines:
                if (not line.lower().startswith("#include")):
                    content += line

        return [content, includes]
        





class AsmCompilator:

    added_files = []

    @staticmethod
    def findModules(script_path):
        file_path = os.path.abspath(script_path)
        dir_path = os.path.dirname(file_path)

        with open(file_path, "r") as f:
            data_lines = f.readlines()

        content = ""
        for line in data_lines:
            if (line.startswith(";import")):
                parts = line.split(" ")

                while " " in parts: 
                    parts.remove("")
                line = ""
                for i in range(1, len(parts)):
                    parts[i] = os.path.join(dir_path, parts[i].strip())
                    if (parts[i] not in AsmCompilator.added_files):
                        if (os.path.exists(parts[i])):
                            line += AsmCompilator.findModules(parts[i])
                            C.prnt("found: ", parts[i])
                            AsmCompilator.added_files.append(parts[i])
                        else:
                            C.prnt(f"ERROR: {parts[i]} does not exists.")
                            exit(1)
            content += line

        return content + "\n\n"

    @staticmethod
    def removeFiles(temp_name, link_name, is_one_file):
        if (not is_one_file and os.path.exists(temp_name)):
            C.prnt("Removing temporary file...")
            os.remove(temp_name)

    @staticmethod
    def compile(script_path, compiler, compiler_args, is_one_file):
        C.prnt("Finding modules...")
        content = AsmCompilator.findModules(script_path) 
        name = script_path.replace(C.POST_FIX, '')
        temp_name = script_path.replace(C.POST_FIX, '_temp.s')
        link_name = temp_name.replace(C.POST_FIX, '.o')
        with open(f"{temp_name}", "w") as f:
            f.write(content)

        C.prnt("Assembling...")
        ret = subprocess.call([compiler, *compiler_args, temp_name])      
        if (ret == 0):
            C.prnt("Linking...")
            ret = subprocess.call(["ld", f"-o", name, link_name])
        AsmCompilator.removeFiles(temp_name, link_name, is_one_file)
        return ret


class InvalidRegex(Exception):
    def __init__(self, description):
        super().__init__(self, "Invalid regex", description)


class Specifier:

    @staticmethod
    def findLimits(val, min, max):
        limits = val.split(",")
        if (val != ""):
            if (len(limits) == 1):
                min = 0
                max = float(limits[0])
            else:
                min = float(limits[0])
                max = float(limits[1])
        return min, max

    @staticmethod
    def char(val):
        val = val.replace("%", "").replace("c", "")
        return random.choice(string.ascii_letters)

    @staticmethod
    def decimal(val):
        val = val.replace("%", "").replace("d", "")
        min, max = Specifier.findLimits(val, -32768, 32768)

        return str(random.randrange(int(min), int(max)))

    @staticmethod
    def string(val):
        val = val.replace("%", "").replace("s", "")
        min, max = Specifier.findLimits(val, -1, 100)

        if (min != -1):
            length = random.randrange(int(min), int(max))
        else:
            length = max

        return "".join(random.choices(string.ascii_letters + string.digits,
                k=length))

    @staticmethod
    def double(val):
        val = val.replace("%", "").replace("g", "")
        min, max = Specifier.findLimits(val,
            2.3*math.pow(10, -308),
            1.7*math.pow(10, 308))
        
        return str(random.uniform(min, max))

    @staticmethod
    def flt(val):
        val = val.replace("%", "").replace("f", "")
        min, max = Specifier.findLimits(val,
            1.2*math.pow(10, -38),
            3.4*math.pow(10, 38))
        
        return str(random.uniform(min, max))

    @staticmethod
    def octa(val):
        val = val.replace("%", "").replace("o", "")
        s = Specifier.decimal(val)
        return oct(int(s))

    @staticmethod
    def unsigned(val):
        val = val.replace("%", "").replace("u", "")
        min, max = Specifier.findLimits(val, 0, 65536)

        if (min < 0): min = 0

        return str(random.randrange(int(min), int(max)))

    @staticmethod
    def hexa(val):
        val = val.replace("%", "").replace("x", "")
        s = Specifier.decimal(val)
        return hex(int(s))

    @staticmethod
    def hexA(val):
        val = val.replace("%", "").replace("X", "")
        s = Specifier.decimal(val)
        return hex(int(s)).upper()



class Runner:
	
	@staticmethod
	def convertTime(tm):
		if (C.MILLI_SECONDS): return f"{1000 * tm} ms"
		return f"{tm} s"

	@staticmethod
	def readFiles(files_path):
		return sorted( filter( lambda x: os.path.isfile(os.path.join(files_path, x)),
		                os.listdir(files_path) ) )

	@staticmethod
	def run(input_file, cmd):
		tm = time.time()
		if (C.RAW):			
			process = subprocess.Popen(cmd, text=True,
				stdin=open(input_file, "rb"))
		else:
			process = subprocess.Popen(cmd, text=True,
				stdin=open(input_file, "rb"),
				stdout=subprocess.PIPE,
				stderr=subprocess.STDOUT)

		ret = process.wait()
		out = None
		if (not C.RAW):
			out = process.stdout.read()

		return ret, out, time.time() - tm

	@staticmethod		
	def runTests(files_path, cmd):
		counter = 0
		fails = 0
		
		if (os.path.isdir(files_path)):
			files = Runner.readFiles(files_path)

			for file in files:
				if (file.find("_in") == -1): continue
				
				C.prnt("")
				C.prnt(f"{C.HEADER}{5*'='}Test {counter}. - {file}{5*'='}{C.ENDC}")
				counter += 1
				
				fails += Runner.runOneFile(os.path.join(files_path, file), cmd)
		else:
			C.prnt("")
			C.prnt(f"{C.HEADER}{5*'='}Test {counter}. - {files_path}{5*'='}{C.ENDC}")
			counter += 1
			
			fails = Runner.runOneFile(files_path, cmd)
			
		C.prnt(C.HEADER + 20*"=" + C.ENDC)
		C.prnt(f"Test count: {counter}")
		C.prnt(f"Failed tests: {fails}")

	@staticmethod
	def printInput(file):
		with open(file, "r", encoding="utf-8") as f:
				in_data = f.read()
		C.prnt("")
		C.prnt("Input:")		
		C.prnt(in_data)

	@staticmethod
	def compare(out_split, temp_split):
		max_len = 29
		for line in out_split:
			if (max_len < len(line)):
				max_len = len(line)
		max_len += 1

		delimiter = f"{C.BOLD}{C.OKBLUE}|{C.ENDC}"

		for line1, line2 in zip(out_split, temp_split):
			h = f"{C.OKGREEN}>> {C.ENDC}"
			if (line1 != line2): h = f"{C.FAIL}>> {C.ENDC}"
			C.prnt(f"{h}{line1}{(max_len - len(line1)) * ' '} {delimiter} {line2}")
			
		if (len(out_split) > len(temp_split)):
			for i in range(len(temp_split), len(out_split)):
				line = out_split[i]
				C.prnt(f"{C.FAIL}>> {C.ENDC}" + line)
				
		elif (len(temp_split) > len(out_split)):
			for i in range(len(out_split), len(temp_split)):
				line = temp_split[i]
				C.prnt(f"{C.FAIL}>> {C.ENDC}" + ((max_len * " ") + f" {delimiter} " + line))
		
		
	@staticmethod
	def runOneFile(file, cmd):
		if (C.RAW):
			Runner.printInput(file)
			C.prnt("")
			C.prnt("Output:")

		ret, out, tm = Runner.run(file, cmd.copy())
		if (ret != 0):
			C.prnt(f"{C.WARNING}{10*'='}Process ended with code {C.OKBLUE}{ret}{C.WARNING}{10*'='}{C.ENDC}")			
		
		if (C.RAW):
			C.prnt("")
			C.prnt(5*"=")
			C.prnt(f"Time: {Runner.convertTime(tm)}")
			return 0

		temp_file = file
		if (C.TESTS):
			temp_file = temp_file.replace("in", "out")

		if (not os.path.exists(temp_file)):
			temp_file = file
			C.prnt(f"{C.WARNING}!!!MISSING TEMPLATE FILE!!!{C.ENDC}")
			C.prnt(f"{C.WARNING}Comparing with input file{C.ENDC}")
			C.prnt(f"{C.WARNING}Rerun with -t parameter to get rid of this warning{C.ENDC}")

		with open(temp_file, "r", encoding="utf-8") as fo:
			temp = fo.read()
		
		if (temp != out and C.TESTS):	
			Runner.printInput(file)
			
			out_split = out.split("\n")
			temp_split = temp.split("\n")
			
			C.prnt("")
			C.prnt("Output:")
			
			Runner.compare(out_split, temp_split)

			C.prnt("")
			C.prnt(5*"=")
			C.prnt(f"{C.FAIL}Output not matching{C.ENDC}")
			C.prnt(f"Time: {Runner.convertTime(tm)}")
			return 1
		elif (C.TESTS):
			C.prnt(f"{C.OKGREEN}OK{C.ENDC}")
			C.prnt(f"Time: {Runner.convertTime(tm)}")
			return 0
		else:
			out_split = out.split("\n")
			temp_split = temp.split("\n")
			
			C.prnt("")
			C.prnt("Output:")
			
			Runner.compare(out_split, temp_split)

			C.prnt("")
			C.prnt(5*"=")
			C.prnt(f"Time: {Runner.convertTime(tm)}")
			return 0



class Compilator:

	@staticmethod
	def findModules(script_path):
		headers = [] 
		sources = []
		for root, dirs, files in os.walk(os.path.dirname(os.path.abspath(script_path))):
			for f in files:
				if (f.endswith(".h")):
					headers.append(f.replace(".h", ".o"))
				elif (f.endswith(".c")):
					sources.append(f.replace(".c", ".o"))
					
		modules = []
		for source in sources: 
			if (source in headers):	
				modules.append(source)
				C.prnt("Adding module:", source) 
		return modules

	@staticmethod
	def removeLinks(script_path):
		for root, dirs, files in os.walk(os.path.dirname(os.path.abspath(script_path))):
			for f in files:
				if (f.endswith(".o")): os.remove(f)

	@staticmethod
	def addFflush(script_path):
		with open(script_path, "r", encoding="utf-8") as f:
			data_lines = f.readlines()

		for i, line in enumerate(data_lines):
			if (line.strip().startswith("printf") and C.FFLUSH):
				data_lines[i] = line.replace("\n", " ") + "fflush(stdout);\n"
	
		with open(script_path.replace(".c", "_temp.c"), "w", encoding="utf-8") as f:
			f.write("".join(data_lines))

	@staticmethod
	def compile(script_path, compiler, compiler_args, is_one_file):
		if (C.MODE):
			return AsmCompilator.compile(script_path, compiler, compiler_args, is_one_file)
		
		Compilator.addFflush(script_path)

		name = os.path.basename(script_path).replace(".c", "") + "_temp"
		
		if (not is_one_file):
			modules = Compilator.findModules(script_path)

			mkf = M.MAKE_FILE_TEMP
			mkf = mkf.replace("$NAME$", name)
			mkf = mkf.replace("$MODULES$", " ".join(modules))
			mkf = mkf.replace("$COMPILER$", compiler)
			mkf = mkf.replace("$COMPILER_ARGS$", " ".join(compiler_args))
			
			with open("Makefile", "w") as f:
				f.write(mkf)
			
			ret = subprocess.call(["make"])
		else:
			ret = subprocess.call([compiler, *compiler_args, script_path, "-o", name])

		os.remove(script_path.replace(".c", "_temp.c"))
		if (os.path.exists(script_path.replace(".c", "_temp"))):
			os.rename(script_path.replace(".c", "_temp"), script_path.replace(".c", ""))
			
		return ret


class M:
	MAKE_FILE_TEMP = """
# MAKEFILE GENERATED BY PTT
# https://github.com/KubaBoi/ptt

NAME=$NAME$
OBJFILES=$(NAME).o $MODULES$

CC=$COMPILER$
CFLAGS= $COMPILER_ARGS$

%.o : %.c 
	$(CC) $(CFLAGS) -c $<

all: $(NAME)

dep:
	$(CC) -MM *.c >dep.list

-include dep.list

$(NAME): $(OBJFILES)
	$(CC) $(CFLAGS) $(OBJFILES) -o $@
	"""


class V:
	VERSION = "1.0.16"


class C:
	HEADER = '\033[95m'
	OKBLUE = '\033[94m'
	OKCYAN = '\033[96m'
	OKGREEN = '\033[92m'
	WARNING = '\033[93m'
	FAIL = '\033[91m'
	ENDC = '\033[0m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'
	
	SILENT = False
	MILLI_SECONDS = False
	RAW = False
	TESTS = True
	FFLUSH = True
	# 0 - C
	# 1 - ASSEMBLER
	MODE = 0 
	POST_FIX = ".c"
	
	@staticmethod
	def noColors():
		members = inspect.getmembers(C, lambda a:not(inspect.isroutine(a)))
		for i in members:
			if (i[0][0] != "_"): setattr(C, i[0], "")
			
	@staticmethod
	def silent():
		C.SILENT = True
		
	@staticmethod
	def milliseconds():
		C.MILLI_SECONDS = True

	@staticmethod
	def raw():
		C.RAW = True

	@staticmethod
	def tests():
		C.TESTS = False
			
	@staticmethod
	def prnt(*str):
		if (not C.SILENT): print(*str)

	@staticmethod
	def fflush():
		C.FFLUSH = False

	@staticmethod
	def assembler():
		C.MODE = 1
		C.POST_FIX = ".s"
		C.fflush()


def main():
	"""
	Entry point into the program.
	"""
	
	parser = argparse.ArgumentParser(
		prog="ptt",
		description="Test tool for ProgTest from CVUT FIT",
		epilog="Full documentation 'man ptt'")
		
	parser.add_argument("filename", 
			help="Path to C/C++ script")
			
	parser.add_argument("-v", "--version", action="store_true", default=False,
			help="Show version")
			
	parser.add_argument("-d", "--data-path", action="store", default=False,
		        help="Path to directory with test data. If path is file, then script is runned only once with data from path file. If not included, then script is runned only once and waits for users input.")
	parser.add_argument("-l", "--valgrind", action="store_true",
			help="Script is runned under Valgrind")
	parser.add_argument("-L", "--val-args", action="store", default="",
			help="Arguments for Valgrind as string and needs to start with \\")
	parser.add_argument("-g", "--gdb", action="store_true", default=False,
			help="Script is runned under GDB")
	parser.add_argument("-D", "--val-data", action="store", default="",
			help="Data for Valgrind as string")
	parser.add_argument("-c", "--compiler", action="store", default="g++",
			help="Compiler (default is g++)")
	parser.add_argument("-C", "--compiler-args", action="store", default="\\-Wall -pedantic",
			help="Arguments for compiler (default is '-Wall -pedantic')")
	parser.add_argument("-k", "--keep-links", action="store_true", default=False,
			help="Keeps link (.o) files from compilation")

	parser.add_argument("--generate", action="store_true", default=False,
			help="Starts generator for new dataset and then tests the script")
	parser.add_argument("-o", "--output", action="store", default="",
			help="Makes one .c file from all .h and .c source files. And runs this one .c file. If script is ASM, ptt will not remove temporary file after compilation.")

	parser.add_argument("-r", "--raw", action="store_true", default=False,
			help="Runs tests but only prints output to terminal. Does not compare with anything")
	parser.add_argument("-t", "--tests", action="store_true", default=False,
			help="Runs tests but does not compare them with output templates but with it's input")
	parser.add_argument("-m", "--milli-seconds", action="store_true", default=False,
			help="Time is counted in milliseconds")
	parser.add_argument("-s", "--silent", action="store_true", default=False,
			help="ptt will be silent (compiler, valgrind and tested script won't be)")
	parser.add_argument("-n", "--no-colors", action="store_true", default=False,
			help="Output is without any colors")
	parser.add_argument("-q", "--quit-fflush", action="store_true", default=False,
			help="Turn off adding 'fflush()' after every 'printf()' in script. Output would not be reachable for ptt if process ends by error.")
	
	args = parser.parse_args()
	script_path = args.filename
	is_one_file = False

	if (script_path.endswith(".s")):
		C.assembler()
		if (args.compiler_args == "\\-Wall -pedantic"):
			args.compiler_args = "\\-f elf64"
		if (args.compiler == "g++"):
			args.compiler = "nasm"

	
	if (args.no_colors):
		C.noColors()
	if (args.silent):
		C.silent()
	if (args.milli_seconds):
		C.milliseconds()
	if (args.raw):
		C.raw()
	if (args.tests):
		C.tests()
	if (args.output != ""):
		is_one_file = True
		if (C.MODE == 0):
			script_path = Builder.build(script_path, args.output)
			if (script_path == 0): 
				C.prnt(f"{C.WARNING}Cannot make one file source code because{C.ENDC}")
				C.prnt(f"{C.WARNING}chosen name is same as main script.{C.ENDC}")
				return
	if (args.quit_fflush):
		C.fflush()
	
	if (args.valgrind):
		val_args = args.val_args.replace("\\", "").strip()
		cmd = ["valgrind", f"{val_args}", f"./{script_path.replace(C.POST_FIX, '')}", f"{args.val_data}"]
	elif (args.gdb):
		cmd = ["gdb", f"./{script_path.replace(C.POST_FIX, '')}"]
	else:
		cmd = [f"./{script_path.replace(C.POST_FIX, '')}"]
	
	while ("" in cmd):
		cmd.remove("")
	
	compiler = args.compiler
	compiler_args = args.compiler_args.replace("\\", "").split(" ")

	compil = Compilator.compile(script_path, compiler, compiler_args, is_one_file)
	if (compil == 0):
		C.prnt(f"{C.OKGREEN}{10*'='}Compilation process OK{10*'='}{C.ENDC}")
		
		if (not args.keep_links):
			Compilator.removeLinks(script_path)
	
		if (not args.data_path):
			subprocess.call(cmd)
		else:
			Runner.runTests(args.data_path, cmd)
		
		C.prnt("\n")
		C.prnt("Testing done:")
		C.prnt("Compiler:", compiler)
		C.prnt("Compiler args:", *compiler_args)
		C.prnt("Valgrind:", args.valgrind)
		C.prnt("Valgrind args:", args.val_args)
		C.prnt("")
		if (C.MODE == 0):
			if ("-Wall" not in compiler_args or "-pedantic" not in compiler_args):
				C.prnt(f"{C.WARNING}WARNING - there is missing -Wall or -pedantic in compilation{C.ENDC}")
			if (not args.valgrind):
				if (args.val_args != ""):
					C.prnt(f"{C.WARNING}WARNING - there are valgrind arguments (-L) specified but valgrind (-l) is not enabled{C.ENDC}")
				if (args.val_data != ""):
					C.prnt(f"{C.WARNING}WARNING - there are valgrind data (-D) specified but valgrind (-l) is not enabled{C.ENDC}")
	else:
		C.prnt(f"{C.FAIL}{10*'='}Compilation process ended with code {C.OKCYAN}{compil}{C.FAIL}{10*'='}{C.ENDC}")

if (__name__ == "__main__"):
	args = args = sys.argv
	if (len(args) > 1):
		if (args[1] == "-v" or args[1] == "--version"):
			exit(f"ProgTestTest v({V.VERSION})")
		elif (args[1] == "-g" or args[1] == "--generate"):
			g = Generator()
			count = int(input("How many files do you want to generate? "))
			g.generate(count)
			exit()
	exit(main())

